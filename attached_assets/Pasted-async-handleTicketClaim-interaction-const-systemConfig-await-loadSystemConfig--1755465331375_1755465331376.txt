async handleTicketClaim(interaction) {
        const systemConfig = await loadSystemConfig();
        const tickets = await loadTickets();

        const ticket = tickets.find(t => t.channelId === interaction.channel.id);
        if (!ticket) return await interaction.reply({ content: 'âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ°ÙƒØ±Ø©.', ephemeral: true });

        if (ticket.claimedBy) return await interaction.reply({ content: 'âŒ Ù‡Ø°Ù‡ Ø§Ù„ØªØ°ÙƒØ±Ø© Ù…Ø³ØªÙ„Ù…Ø© Ø¨Ø§Ù„ÙØ¹Ù„.', ephemeral: true });

        if (ticket.userId === interaction.user.id) {
            return await interaction.reply({ content: 'âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„ØªØ°ÙƒØ±Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ.', ephemeral: true });
        }

        const ticketConfig = systemConfig.ticketTypes[ticket.type];
        const hasPermission = interaction.member.roles.cache.some(role => ticketConfig.roles.includes(role.id)) 
            || interaction.member.permissions.has(PermissionFlagsBits.Administrator);

        if (!hasPermission) {
            return await interaction.reply({ content: 'âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø§Ø³ØªÙ„Ø§Ù… Ù‡Ø°Ù‡ Ø§Ù„ØªØ°ÙƒØ±Ø©.', ephemeral: true });
        }

        ticket.claimedBy = interaction.user.id;
        ticket.claimedAt = new Date().toLocaleString('en-US', { timeZone: 'UTC' });

        // Ø¥Ø¶Ø§ÙØ© ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù… Ø¥Ù„Ù‰ Ø§Ù„Ø³Ø¬Ù„
        if (!ticket.claimHistory) ticket.claimHistory = [];
        ticket.claimHistory.push({
            userId: interaction.user.id,
            action: 'claimed',
            timestamp: new Date().toLocaleString('en-US', { timeZone: 'UTC' }),
            isAdminAction: interaction.member.permissions.has(PermissionFlagsBits.Administrator)
        });

        await saveTickets(tickets);

        await this.addTicketPoint(interaction.user.id);

        const updatedEmbed = EmbedBuilder.from(interaction.message.embeds[0])
            .setFields(
                { name: 'User', value: `<@${ticket.userId}>`, inline: true },
                { name: 'Type', value: ticketConfig.name, inline: true },
                { name: 'Status', value: 'Claimed', inline: true },
                { name: 'Claimed by', value: `<@${interaction.user.id}>`, inline: true },
                { name: 'Claimed at', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true }
            )
            .setColor(0x00ff00);

        const buttonRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder().setCustomId('ticket_unclaim').setLabel('Unclaim').setStyle(ButtonStyle.Secondary).setEmoji('â†ªï¸'),
                new ButtonBuilder().setCustomId('ticket_close').setLabel('Close').setStyle(ButtonStyle.Danger).setEmoji('ğŸ”’')
            );

        const manageMenu = new StringSelectMenuBuilder()
            .setCustomId('ticket_manage')
            .setPlaceholder('Ticket Management Options')
            .addOptions(
                { label: 'Add/Remove User', description: 'Add or remove a user from this ticket', value: 'add_user', emoji: 'ğŸ‘¤' },
                { label: 'Summon User', description: 'Send DM to user to come to ticket', value: 'summon_user', emoji: 'ğŸ“¨' },
                { label: 'Blacklist User', description: 'Add user to blacklist', value: 'blacklist_user', emoji: 'ğŸš«' },
                { label: 'Rename Ticket', description: 'Change ticket name', value: 'rename_ticket', emoji: 'âœï¸' },
                { label: 'Channel Permissions', description: 'Manage channel permissions', value: 'channel_permissions', emoji: 'ğŸ”§' }
            );

        const manageRow = new ActionRowBuilder().addComponents(manageMenu);

        await interaction.update({ embeds: [updatedEmbed], components: [buttonRow, manageRow] });
    }

    async handleTicketUnclaim(interaction) {
        const systemConfig = await loadSystemConfig();
        const tickets = await loadTickets();

        const ticket = tickets.find(t => t.channelId === interaction.channel.id);
        if (!ticket) return await interaction.reply({ content: 'âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ°ÙƒØ±Ø©.', ephemeral: true });

        if (!ticket.claimedBy) return await interaction.reply({ content: 'âŒ Ù‡Ø°Ù‡ Ø§Ù„ØªØ°ÙƒØ±Ø© ØºÙŠØ± Ù…Ø³ØªÙ„Ù…Ø© Ø­Ø§Ù„ÙŠØ§Ù‹.', ephemeral: true });

        if (ticket.claimedBy !== interaction.user.id && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return await interaction.reply({ content: 'âŒ ÙÙ‚Ø· Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù„ÙŠ Ø§Ø³ØªÙ„Ù… Ø§Ù„ØªØ°ÙƒØ±Ø© ÙŠÙ‚Ø¯Ø± ÙŠÙÙƒ Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù….', ephemeral: true });
        }

        // Ø¥Ø¶Ø§ÙØ© ØªØ§Ø±ÙŠØ® ÙÙƒ Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù… Ø¥Ù„Ù‰ Ø§Ù„Ø³Ø¬Ù„
        if (!ticket.claimHistory) ticket.claimHistory = [];
        ticket.claimHistory.push({
            userId: interaction.user.id,
            action: 'unclaimed',
            timestamp: new Date().toLocaleString('en-US', { timeZone: 'UTC' }),
            isAdminAction: interaction.member.permissions.has(PermissionFlagsBits.Administrator)
        });

        ticket.claimedBy = null;
        ticket.claimedAt = null;
        await saveTickets(tickets);

        const ticketConfig = systemConfig.ticketTypes[ticket.type];
        const updatedEmbed = EmbedBuilder.from(interaction.message.embeds[0])
            .setFields(
                { name: 'User', value: `<@${ticket.userId}>`, inline: true },
                { name: 'Type', value: ticketConfig.name, inline: true },
                { name: 'Status', value: 'Open', inline: true }
            )
            .setColor(0x0099ff);

        const buttonRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder().setCustomId('ticket_claim').setLabel('Claim').setStyle(ButtonStyle.Primary).setEmoji('âœ‹'),
                new ButtonBuilder().setCustomId('ticket_close').setLabel('Close').setStyle(ButtonStyle.Danger).setEmoji('ğŸ”’')
            );

        const manageMenu = new StringSelectMenuBuilder()
            .setCustomId('ticket_manage')
            .setPlaceholder('Ticket Management Options')
            .addOptions(
                { label: 'Add/Remove User', description: 'Add or remove a user from this ticket', value: 'add_user', emoji: 'ğŸ‘¤' },
                { label: 'Summon User', description: 'Send DM to user to come to ticket', value: 'summon_user', emoji: 'ğŸ“¨' },
                { label: 'Blacklist User', description: 'Add user to blacklist', value: 'blacklist_user', emoji: 'ğŸš«' },
                { label: 'Rename Ticket', description: 'Change ticket name', value: 'rename_ticket', emoji: 'âœï¸' },
                { label: 'Channel Permissions', description: 'Manage channel permissions', value: 'channel_permissions', emoji: 'ğŸ”§' }
            );

        const manageRow = new ActionRowBuilder().addComponents(manageMenu);

        await interaction.update({ embeds: [updatedEmbed], components: [buttonRow, manageRow] });
        await interaction.channel.send(`â†©ï¸ <@${interaction.user.id}> ÙÙƒ Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„ØªØ°ÙƒØ±Ø©. ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¢Ù† Ù„Ø£ÙŠ Ø¥Ø¯Ø§Ø±ÙŠ Ø§Ø³ØªÙ„Ø§Ù…Ù‡Ø§.`);
    }

    async handleTicketClose(interaction) {
        const systemConfig = await loadSystemConfig();
        const tickets = await loadTickets();
        const ticket = tickets.find(t => t.channelId === interaction.channel.id);

        if (!ticket) return await interaction.reply({ content: 'âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ°ÙƒØ±Ø©.', ephemeral: true });

        const canClose = ticket.claimedBy === interaction.user.id || 
                        interaction.member.permissions.has(PermissionFlagsBits.Administrator);

        if (!canClose) {
            return await interaction.reply({ content: 'âŒ ÙŠÙ…ÙƒÙ† ÙÙ‚Ø· Ù„Ù„Ø£Ø¯Ù…Ù† Ø§Ù„Ø°ÙŠ Ø§Ø³ØªÙ„Ù… Ø§Ù„ØªØ°ÙƒØ±Ø© Ø£Ùˆ Ø§Ù„Ù…Ø¯ÙŠØ± Ø¥ØºÙ„Ø§Ù‚Ù‡Ø§.', ephemeral: true });
        }

        try {
            ticket.status = 'closed';
            ticket.closedBy = interaction.user.id;
            ticket.closedAt = new Date().toLocaleString('en-US', { timeZone: 'UTC' });
            await saveTickets(tickets);

            const claimRequests = await loadClaimRequests();
            const updatedRequests = claimRequests.filter(req => req.channelId !== interaction.channel.id);
            await saveClaimRequests(updatedRequests);

            await interaction.reply('ğŸ”’ Ø³ÙŠØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø© Ø®Ù„Ø§Ù„ 5 Ø«ÙˆØ§Ù†...');

            setTimeout(async () => {
                try {
        // 1. Ø¬ÙŠØ¨ Ø§Ù„Ù‚Ù†Ø§Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø­Ø°Ù
                    const channel = interaction.guild.channels.cache.get(ticket.channelId);

        // 2. Ø³ÙˆÙ‘ÙŠ Ø§Ù„ØªØ±Ø§Ù†Ø³ÙƒØ±ÙŠØ¨Øª ÙˆØ£Ø±Ø³Ù„ Ø§Ù„Ù„ÙˆÙ‚
                    await this.logTicketClosure(interaction.guild, ticket, systemConfig);

        // 3. Ø¨Ø¹Ø¯ Ù…Ø§ ÙŠÙ†Ø±Ø³Ù„ Ø§Ù„Ù„ÙˆÙ‚ Ø§Ø­Ø°Ù Ø§Ù„Ù‚Ù†Ø§Ø©
                    if (channel) await channel.delete();
                } catch (error) {
                    console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø£Ùˆ Ø­Ø°Ù Ù‚Ù†Ø§Ø© Ø§Ù„ØªØ°ÙƒØ±Ø©:', error);
                    }
            }, 5000);

        } catch (error) {
            console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø©:', error);
            await interaction.reply({ content: 'âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø©.', ephemeral: true });
        }
    }

    async logTicketClosure(guild, ticket, systemConfig) {
        try {
            const logChannel = guild.channels.cache.get(systemConfig.logChannelId);
            if (!logChannel) return;

            const ticketTypeName = getTicketTypeName(ticket.type, systemConfig);
            const user = await guild.members.fetch(ticket.userId).catch(() => null);
            const closer = await guild.members.fetch(ticket.closedBy).catch(() => null);
            const claimer = ticket.claimedBy ? await guild.members.fetch(ticket.claimedBy).catch(() => null) : null;
            const channel = guild.channels.cache.get(ticket.channelId);

            if (!channel) {
                console.error(`Could not find channel for ticket ${ticket.id}`);
                return;
            }

            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…
            let claimHistoryText = 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…';
            if (ticket.claimHistory && ticket.claimHistory.length > 0) {
                claimHistoryText = ticket.claimHistory.map(claim => {
                    const action = claim.action === 'claimed' ? 'Ø§Ø³ØªÙ„Ù…' : 'ÙÙƒ Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…';
                    const adminText = claim.isAdminAction ? ' (Ù…Ø¯ÙŠØ±)' : '';
                    const timestamp = `<t:${Math.floor(new Date(claim.timestamp).getTime() / 1000)}:R>`;
                    return `â€¢ <@${claim.userId}> ${action}${adminText} ${timestamp}`;
                }).join('\n');
            }

            const logEmbed = new EmbedBuilder()
                .setTitle('ğŸ”’ ØªÙ… Ø¥ØºÙ„Ø§Ù‚ ØªØ°ÙƒØ±Ø©')
                .setDescription('Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ°ÙƒØ±Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Ø§Ù„ØªØ±Ø§Ù†Ø³ÙƒØ±ÙŠØ¨Øª')
                .setColor(0xff0000)
                .addFields(
                    { name: 'ğŸ†” Ù…Ø¹Ø±Ù Ø§Ù„ØªØ°ÙƒØ±Ø©', value: ticket.id, inline: true },
                    { name: 'ğŸ“‹ Ù†ÙˆØ¹ Ø§Ù„ØªØ°ÙƒØ±Ø©', value: ticketTypeName, inline: true },
                    { name: 'ğŸ“Š Ø§Ù„Ø­Ø§Ù„Ø©', value: 'Ù…ÙØºÙ„Ù‚Ø©', inline: true },
                    { name: 'ğŸ‘¤ Ù…Ù†Ø´Ø¦ Ø§Ù„ØªØ°ÙƒØ±Ø©', value: user ? `<@${ticket.userId}>` : `Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¬Ù‡ÙˆÙ„ (${ticket.userId})`, inline: true },
                    { name: 'ğŸ”’ Ù…ÙØºÙ„Ù‚Ø© Ø¨ÙˆØ§Ø³Ø·Ø©', value: closer ? `<@${ticket.closedBy}>` : `Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¬Ù‡ÙˆÙ„ (${ticket.closedBy})`, inline: true },
                    { name: 'â° Ù…Ø¯Ø© Ø§Ù„ØªØ°ÙƒØ±Ø©', value: this.calculateDuration(ticket.createdAt, ticket.closedAt), inline: true },
                    { name: 'ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡', value: `<t:${Math.floor(new Date(ticket.createdAt).getTime() / 1000)}:F>`, inline: true },
                    { name: 'ğŸ”’ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥ØºÙ„Ø§Ù‚', value: `<t:${Math.floor(new Date(ticket.closedAt).getTime() / 1000)}:F>`, inline: true },
                    { name: 'ğŸ“‹ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…', value: claimHistoryText, inline: false }
                )
                .setTimestamp()
                .setFooter({ text: 'MT Community Tickets' });

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ±Ø§Ù†Ø³ÙƒØ±ÙŠØ¨Øª
            const messages = await this.fetchAllMessages(channel);
            const transcriptHTML = await this.formatTranscript(messages, ticket, channel);

            if (transcriptHTML) {
                await logChannel.send({
                    embeds: [logEmbed],
                    files: [{
                        attachment: Buffer.from(transcriptHTML, 'utf8'),
                        name: `ticket-${channel.name}-${Date.now()}.html`
                    }]
                });
            } else {
                await logChannel.send({ embeds: [logEmbed] });
            }

        } catch (error) {
            console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø©:', error);
        }
    }

    // Ø¯Ø§Ù„Ø© Ù…Ø­Ø¯Ø«Ø© Ù„Ù„ØªØ±Ø§Ù†Ø³ÙƒØ±ÙŠØ¨Øª
    async createTranscript(channel, ticketData) {
        try {
            const messages = await this.fetchAllMessages(channel);
            const transcript = await this.formatTranscript(messages, ticketData, channel);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¥ÙŠÙ…Ø¨Ø¯ Ù„Ù„ØªØ±Ø§Ù†Ø³ÙƒØ±ÙŠØ¨Øª
            const transcriptEmbed = new EmbedBuilder()
                .setTitle(`ğŸ“‹ ØªØ±Ø§Ù†Ø³ÙƒØ±ÙŠØ¨Øª Ø§Ù„ØªØ°ÙƒØ±Ø©`)
                .setColor(config.COLORS.PRIMARY)
                .addFields(
                    { name: 'ğŸ« Ø§Ø³Ù… Ø§Ù„ØªØ°ÙƒØ±Ø©', value: `#${channel.name}`, inline: true },
                    { name: 'ğŸ‘¤ Ù…Ù†Ø´Ø¦ Ø§Ù„ØªØ°ÙƒØ±Ø©', value: `<@${ticketData.userId}>`, inline: true },
                    { name: 'ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡', value: ticketData.createdAt || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯', inline: true },
                    { name: 'ğŸ”’ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥ØºÙ„Ø§Ù‚', value: new Date().toLocaleString('en-US', { timeZone: 'UTC' }), inline: true },
                    { name: 'ğŸ’¬ Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„', value: messages.length.toString(), inline: true },
                    { name: 'â±ï¸ Ù…Ø¯Ø© Ø§Ù„ØªØ°ÙƒØ±Ø©', value: this.calculateDuration(ticketData.createdAt), inline: true }
                )
                .setTimestamp()
                .setFooter({ text: 'MT Community Tickets' });

            // Ø¥Ø¶Ø§ÙØ© ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù… Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
            if (ticketData.claimHistory && ticketData.claimHistory.length > 0) {
                const claimInfo = ticketData.claimHistory
                    .map(claim => {
                        const action = claim.action === 'claimed' ? 'Ø§Ø³ØªÙ„Ù…' : 'ÙÙƒ Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…';
                        const adminText = claim.isAdminAction ? ' (Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø¯ÙŠØ±)' : '';
                        return `â€¢ <@${claim.userId}> ${action} Ø§Ù„ØªØ°ÙƒØ±Ø©${adminText}`;
                    })
                    .join('\n');

                transcriptEmbed.addFields({ 
                    name: 'ğŸ“‹ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…', 
                    value: claimInfo, 
                    inline: false 
                });
            }

            // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ±Ø§Ù†Ø³ÙƒØ±ÙŠØ¨Øª Ù„Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
            const logChannel = channel.guild.channels.cache.get('1387340403983908997'); // Replace with your actual log channel ID
            if (logChannel) {
                await logChannel.send({
                    embeds: [transcriptEmbed],
                    files: [{
                        attachment: Buffer.from(transcript, 'utf8'),
                        name: `ticket-${channel.name}-${Date.now()}.html`
                    }]
                });
            }
        } catch (error) {
            console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ±Ø§Ù†Ø³ÙƒØ±ÙŠØ¨Øª:', error);
        }
    }

    async fetchAllMessages(channel) {
        const messages = [];
        let lastId;
        while (true) {
            const fetched = await channel.messages.fetch({ limit: 100, before: lastId });
            if (fetched.size === 0) break;
            messages.push(...fetched.values());
            lastId = fetched.last().id;
        }